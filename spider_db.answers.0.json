[{"solution": "<div class=\"post-text\" itemprop=\"text\">&#13;\n<p>Avoid sending back base64 encoded images (multiple images + large files + large encoded strings = very slow performance). I'd highly recommend creating a microservice that only handles image uploads and any other image related get/post/put/delete requests. Separate it from your main application. </p>\n\n<p>For example:</p>\n\n<ul>\n<li>I use multer to create an image buffer</li>\n<li>Then use sharp or fs to save the image (depending upon file type)</li>\n<li>Then I send the filepath to my controller to be saved to my DB</li>\n<li>Then, the front-end does a GET request when it tries to access: <code>http://localhost:4000/uploads/timestamp-randomstring-originalname.fileext</code></li>\n</ul>\n\n<p><strong>In simple terms, my microservice acts like a CDN solely for images.</strong></p>\n\n<hr/>\n\n<p>For example, a user sends a post request to <code>http://localhost:4000/api/avatar/create</code> with some FormData:</p>\n\n<p>It first passes through some Express middlewares:</p>\n\n<p><strong>libs/middlewares.js</strong></p>\n\n<pre><code>...\napp.use(cors({credentials: true, origin: http://localhost:3000 })) // allows receiving of cookies from front-end\n\napp.use(morgan(`tiny`)); // logging framework\n\napp.use(multer({\n        limits: {\n            fileSize: 10240000,\n            files: 1,\n            fields: 1\n        },\n        fileFilter: (req, file, next) =&gt; {\n            if (!/\\.(jpe?g|png|gif|bmp)$/i.test(file.originalname)) {\n                req.err = `That file extension is not accepted!`\n                next(null, false)\n            }\n            next(null, true);\n        }\n    }).single(`file`))\n\napp.use(bodyParser.json()); // parses header requests (req.body)\n\napp.use(bodyParser.urlencoded({ limit: `10mb`, extended: true })); // allows objects and arrays to be URL-encoded\n\n...etc     \n</code></pre>\n\n<p>Then, hits the <code>avatars</code> route:</p>\n\n<p><strong>routes/avatars.js</strong></p>\n\n<pre><code>app.post(`/api/avatar/create`, requireAuth, saveImage, create);\n</code></pre>\n\n<p>It then passes through some user authentication, then goes through my <code>saveImage</code> middleware:</p>\n\n<p><strong>services/saveImage.js</strong></p>\n\n<pre><code>const createRandomString = require('../shared/helpers);\nconst fs = require(\"fs\");\nconst sharp = require(\"sharp\");\nconst randomString = createRandomString();\n\nif (req.err || !req.file) {\n  return res.status(500).json({ err: req.err || `Unable to locate the requested file to be saved` })\n  next();\n}\n\nconst filename = `${Date.now()}-${randomString}-${req.file.originalname}`;\nconst filepath = `uploads/${filename}`;\n\nconst setFilePath = () =&gt; { req.file.path = filepath; return next();}\n\n(/\\.(gif|bmp)$/i.test(req.file.originalname))\n    ? fs.writeFile(filepath, req.file.buffer, (err) =&gt; {\n            if (err) { \n              return res.status(500).json({ err: `There was a problem saving the image.`}); \n              next();\n            }\n\n            setFilePath();\n        })\n    : sharp(req.file.buffer).resize(256, 256).max().withoutEnlargement().toFile(filepath).then(() =&gt; setFilePath())\n</code></pre>\n\n<p>If the file is saved, it then sends a <code>req.file.path</code> to my <code>create</code> controller. This gets saved to my DB as a file path and as an image path (the <code>avatarFilePath</code> or <code>/uploads/imagefile.ext</code> is saved for removal purposes and the <code>avatarURL</code> or <code>[http://localhost:4000]/uploads/imagefile.ext</code> is saved and used for the front-end GET request):</p>\n\n<p><strong>controllers/avatars.js</strong> (I'm using Postgres, but you can substitute for Mongo)</p>\n\n<pre><code>create: async (req, res, done) =&gt; {\n            try {\n                const avatarurl = `${apiURL}/${req.file.path}`;\n\n                await db.result(\"INSERT INTO avatars(userid, avatarURL, avatarFilePath) VALUES ($1, $2, $3)\", [req.session.id, avatarurl, req.file.path]);\n\n                res.status(201).json({ avatarurl });\n            } catch (err) { return res.status(500).json({ err: err.toString() }); done(); \n        }\n</code></pre>\n\n<p>Then when the front-end tries to access the <code>uploads</code> folder via <code>&lt;img src={avatarURL} alt=\"image\" /&gt;</code> or <code>&lt;img src=\"[http://localhost:4000]/uploads/imagefile.ext\" alt=\"image\" /&gt;</code>, it gets served up by the microservice:</p>\n\n<p><strong>libs/server.js</strong></p>\n\n<pre><code>const express = require(\"express\");\nconst path = app.get(\"path\");\nconst PORT = 4000;\n\n//============================================================//\n// EXPRESS SERVE AVATAR IMAGES\n//============================================================//\napp.use(`/uploads`, express.static(`uploads`));\n\n//============================================================//\n/* CREATE EXPRESS SERVER */\n//============================================================//\napp.listen(PORT);\n</code></pre>\n\n<p>What it looks when logging requests:</p>\n\n<pre><code>19:17:54 INSERT INTO avatars(userid, avatarURL, avatarFilePath) VALUES ('08861626-b6d0-11e8-9047-672b670fe126', 'http://localhost:4000/uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png', 'uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png')\n\nPOST /api/avatar/create 201 109 - 61.614 ms\n\nGET /uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png 200 3027 - 3.877 ms\n</code></pre>\n\n<p>What the user sees upon successful GET request:</p>\n\n<p><a href=\"https://i.stack.imgur.com/Q7QKw.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/Q7QKw.png\" alt=\"enter image description here\"/></a></p>\n    </div>&#13;\n    ", "language": ["en"], "source_url": "https://stackoverflow.com/questions/52323381/image-returned-from-rest-api-always-displays-broken", "tags": [], "symptom_plain_text": "I am building a content management system for an art portfolio app, with React. The client will POST to the API which uses Mongoose to insert into a MongoDB. The API then queries the DB for the newly inserted image, and returns it to the client. \n\nHere's my code to connect to MongoDB using Mongoose:\n\nmongoose.connect('mongodb://localhost/test').then(() => \nconsole.log('connected to db')).catch(err => console.log(err))\n\nmongoose.Promise = global.Promise\n\nconst db = mongoose.connection\n\ndb.on('error', console.error.bind(console, 'MongoDB connection error:'))\n\nconst Schema = mongoose.Schema;\n\nconst ImgSchema = new Schema({\n  img: { data: Buffer, contentType: String }\n})\n\nconst Img = mongoose.model('Img', ImgSchema)\n\n\nI am using multer and fs to handle the image file. My POST endpoint looks like this:\n\nrouter.post('/', upload.single('image'), (req, res) => {\n  if (!req.file) {\n    res.send('no file')\n  } else {\n    const imgItem = new Img()\n    imgItem.img.data = fs.readFileSync(req.file.path)\n    imgItem.contentType = 'image/png'\n    imgItem\n      .save()\n      .then(data => \n        Img.findById(data, (err, findImg) => {\n          console.log(findImg.img)\n          fs.writeFileSync('api/uploads/image.png', findImg.img.data)\n          res.sendFile(__dirname + '/uploads/image.png')\n        }))\n  } \n})\n\n\nI can see in the file structure that writeFileSync is writing the image to the disk. res.sendFile grabs it and sends it down to the client.\n\nClient side code looks like this:\n\nhandleSubmit = e => {\n    e.preventDefault()\n    const img = new FormData()\n    img.append('image', this.state.file, this.state.file.name)\n    axios\n      .post('http://localhost:8000/api/gallery', img, {\n        onUploadProgress: progressEvent => {\n          console.log(progressEvent.loaded / progressEvent.total)\n        }\n      })\n      .then(res => {\n        console.log('responsed')\n        console.log(res)\n        const returnedFile = new File([res.data], 'image.png', { type: 'image/png' })\n        const reader = new FileReader()\n        reader.onloadend = () => {\n          this.setState({ returnedFile, returned: reader.result })\n        }\n        reader.readAsDataURL(returnedFile)\n      })\n      .catch(err => console.log(err))\n  }\n\n\nThis does successfully place both the returned file and the img data url on state. However, in my application, the image always displays broken.\n\nHere's some screenshots:\n\n\n\n\n\n\n\nHow to fix this?", "solution_plain_text": "Avoid sending back base64 encoded images (multiple images + large files + large encoded strings = very slow performance). I'd highly recommend creating a microservice that only handles image uploads and any other image related get/post/put/delete requests. Separate it from your main application. \n\nFor example:\n\n\nI use multer to create an image buffer\nThen use sharp or fs to save the image (depending upon file type)\nThen I send the filepath to my controller to be saved to my DB\nThen, the front-end does a GET request when it tries to access: http://localhost:4000/uploads/timestamp-randomstring-originalname.fileext\n\n\nIn simple terms, my microservice acts like a CDN solely for images.\n\n\n\nFor example, a user sends a post request to http://localhost:4000/api/avatar/create with some FormData:\n\nIt first passes through some Express middlewares:\n\nlibs/middlewares.js\n\n...\napp.use(cors({credentials: true, origin: http://localhost:3000 })) // allows receiving of cookies from front-end\n\napp.use(morgan(`tiny`)); // logging framework\n\napp.use(multer({\n        limits: {\n            fileSize: 10240000,\n            files: 1,\n            fields: 1\n        },\n        fileFilter: (req, file, next) => {\n            if (!/\\.(jpe?g|png|gif|bmp)$/i.test(file.originalname)) {\n                req.err = `That file extension is not accepted!`\n                next(null, false)\n            }\n            next(null, true);\n        }\n    }).single(`file`))\n\napp.use(bodyParser.json()); // parses header requests (req.body)\n\napp.use(bodyParser.urlencoded({ limit: `10mb`, extended: true })); // allows objects and arrays to be URL-encoded\n\n...etc     \n\n\nThen, hits the avatars route:\n\nroutes/avatars.js\n\napp.post(`/api/avatar/create`, requireAuth, saveImage, create);\n\n\nIt then passes through some user authentication, then goes through my saveImage middleware:\n\nservices/saveImage.js\n\nconst createRandomString = require('../shared/helpers);\nconst fs = require(\"fs\");\nconst sharp = require(\"sharp\");\nconst randomString = createRandomString();\n\nif (req.err || !req.file) {\n  return res.status(500).json({ err: req.err || `Unable to locate the requested file to be saved` })\n  next();\n}\n\nconst filename = `${Date.now()}-${randomString}-${req.file.originalname}`;\nconst filepath = `uploads/${filename}`;\n\nconst setFilePath = () => { req.file.path = filepath; return next();}\n\n(/\\.(gif|bmp)$/i.test(req.file.originalname))\n    ? fs.writeFile(filepath, req.file.buffer, (err) => {\n            if (err) { \n              return res.status(500).json({ err: `There was a problem saving the image.`}); \n              next();\n            }\n\n            setFilePath();\n        })\n    : sharp(req.file.buffer).resize(256, 256).max().withoutEnlargement().toFile(filepath).then(() => setFilePath())\n\n\nIf the file is saved, it then sends a req.file.path to my create controller. This gets saved to my DB as a file path and as an image path (the avatarFilePath or /uploads/imagefile.ext is saved for removal purposes and the avatarURL or [http://localhost:4000]/uploads/imagefile.ext is saved and used for the front-end GET request):\n\ncontrollers/avatars.js (I'm using Postgres, but you can substitute for Mongo)\n\ncreate: async (req, res, done) => {\n            try {\n                const avatarurl = `${apiURL}/${req.file.path}`;\n\n                await db.result(\"INSERT INTO avatars(userid, avatarURL, avatarFilePath) VALUES ($1, $2, $3)\", [req.session.id, avatarurl, req.file.path]);\n\n                res.status(201).json({ avatarurl });\n            } catch (err) { return res.status(500).json({ err: err.toString() }); done(); \n        }\n\n\nThen when the front-end tries to access the uploads folder via <img src={avatarURL} alt=\"image\" /> or <img src=\"[http://localhost:4000]/uploads/imagefile.ext\" alt=\"image\" />, it gets served up by the microservice:\n\nlibs/server.js\n\nconst express = require(\"express\");\nconst path = app.get(\"path\");\nconst PORT = 4000;\n\n//============================================================//\n// EXPRESS SERVE AVATAR IMAGES\n//============================================================//\napp.use(`/uploads`, express.static(`uploads`));\n\n//============================================================//\n/* CREATE EXPRESS SERVER */\n//============================================================//\napp.listen(PORT);\n\n\nWhat it looks when logging requests:\n\n19:17:54 INSERT INTO avatars(userid, avatarURL, avatarFilePath) VALUES ('08861626-b6d0-11e8-9047-672b670fe126', 'http://localhost:4000/uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png', 'uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png')\n\nPOST /api/avatar/create 201 109 - 61.614 ms\n\nGET /uploads/1536891474536-k9c7OdimjEWYXbjTIs9J4S3lh2ldrzV8-android.png 200 3027 - 3.877 ms\n\n\nWhat the user sees upon successful GET request:", "title": "Image returned from REST API always displays broken", "symptom": "<div class=\"post-text\" itemprop=\"text\">&#13;\n&#13;\n<p>I am building a content management system for an art portfolio app, with React. The client will POST to the API which uses Mongoose to insert into a MongoDB. The API then queries the DB for the newly inserted image, and returns it to the client. </p>\n\n<p>Here's my code to connect to MongoDB using Mongoose:</p>\n\n<pre><code>mongoose.connect('mongodb://localhost/test').then(() =&gt; \nconsole.log('connected to db')).catch(err =&gt; console.log(err))\n\nmongoose.Promise = global.Promise\n\nconst db = mongoose.connection\n\ndb.on('error', console.error.bind(console, 'MongoDB connection error:'))\n\nconst Schema = mongoose.Schema;\n\nconst ImgSchema = new Schema({\n  img: { data: Buffer, contentType: String }\n})\n\nconst Img = mongoose.model('Img', ImgSchema)\n</code></pre>\n\n<p>I am using multer and fs to handle the image file. My POST endpoint looks like this:</p>\n\n<pre><code>router.post('/', upload.single('image'), (req, res) =&gt; {\n  if (!req.file) {\n    res.send('no file')\n  } else {\n    const imgItem = new Img()\n    imgItem.img.data = fs.readFileSync(req.file.path)\n    imgItem.contentType = 'image/png'\n    imgItem\n      .save()\n      .then(data =&gt; \n        Img.findById(data, (err, findImg) =&gt; {\n          console.log(findImg.img)\n          fs.writeFileSync('api/uploads/image.png', findImg.img.data)\n          res.sendFile(__dirname + '/uploads/image.png')\n        }))\n  } \n})\n</code></pre>\n\n<p>I can see in the file structure that writeFileSync is writing the image to the disk. res.sendFile grabs it and sends it down to the client.</p>\n\n<p>Client side code looks like this:</p>\n\n<pre><code>handleSubmit = e =&gt; {\n    e.preventDefault()\n    const img = new FormData()\n    img.append('image', this.state.file, this.state.file.name)\n    axios\n      .post('http://localhost:8000/api/gallery', img, {\n        onUploadProgress: progressEvent =&gt; {\n          console.log(progressEvent.loaded / progressEvent.total)\n        }\n      })\n      .then(res =&gt; {\n        console.log('responsed')\n        console.log(res)\n        const returnedFile = new File([res.data], 'image.png', { type: 'image/png' })\n        const reader = new FileReader()\n        reader.onloadend = () =&gt; {\n          this.setState({ returnedFile, returned: reader.result })\n        }\n        reader.readAsDataURL(returnedFile)\n      })\n      .catch(err =&gt; console.log(err))\n  }\n</code></pre>\n\n<p>This does successfully place both the returned file and the img data url on state. However, in my application, the image always displays broken.</p>\n\n<p>Here's some screenshots:</p>\n\n<p><a href=\"https://i.stack.imgur.com/CzPWA.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/CzPWA.png\" alt=\"correct file is written to disk on server\"/></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/86pXn.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/86pXn.png\" alt=\"file is returned from API and placed on application state\"/></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/3qaRB.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/3qaRB.png\" alt=\"returned image is always broken, no matter what image I upload\"/></a></p>\n\n<p>How to fix this?</p>\n    </div>&#13;\n&#13;\n        ", "service": "mongodb"}]